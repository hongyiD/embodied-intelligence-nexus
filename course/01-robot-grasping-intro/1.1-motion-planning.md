# 1.1 机器人运动规划概述

- **作者**: Damon Li
- **日期**: 2026年2月4日

## 1. 概述

机器人运动规划（Robot Motion Planning）是机器人学中的一个核心问题，旨在为机器人寻找一条从起始状态到目标状态的无碰撞路径或轨迹。这个过程需要考虑机器人的运动学、动力学约束以及环境中障碍物的存在。运动规划是实现机器人自主操作的关键技术之一，广泛应用于工业自动化、服务机器人、自动驾驶、医疗手术等领域 [1] [2]。

运动规划的本质是将一个复杂的、连续的运动任务分解为一系列离散的、可执行的动作，同时确保机器人能够安全、高效地完成任务。它通常涉及在机器人的构型空间（C-space）中搜索一条路径，该路径必须完全位于自由空间（C-free space）内，即不与任何障碍物发生碰撞 [3]。

## 2. 核心原理

运动规划的核心挑战在于高维度的构型空间、复杂的障碍物几何形状以及实时性要求。其基本原理可以概括为以下几点：

### 2.1 构型空间 (Configuration Space, C-space)

构型空间是描述机器人所有可能位姿（位置和姿态）的数学空间。一个机器人的构型由一组参数定义，例如关节角度或自由度。在C-space中，机器人被抽象为一个点，而障碍物则被“膨胀”为C-space障碍物（C-obstacles）。运动规划的目标是在C-space的自由空间中找到一条连接起始构型和目标构型的路径 [3]。

### 2.2 碰撞检测

碰撞检测是运动规划中的基础操作，用于判断机器人在给定构型下是否与环境中的障碍物发生碰撞。高效的碰撞检测算法对于实时运动规划至关重要。

### 2.3 路径与轨迹

- **路径 (Path)**：指机器人从起始构型到目标构型的一系列连续构型，不考虑时间信息。
- **轨迹 (Trajectory)**：在路径的基础上，增加了时间信息，即描述了机器人在每个时间点的构型、速度和加速度，需要满足机器人的动力学约束。

## 3. 关键方法/算法

机器人运动规划算法种类繁多，大致可以分为以下几类：

### 3.1 基于采样的方法 (Sampling-based Methods)

这类方法在高维空间中表现出色，通过随机采样构型点来构建图或树，从而搜索路径。它们通常不保证找到最优路径，但能较快地找到可行路径。

- **概率路线图 (Probabilistic Roadmaps, PRM)**：PRM通过在C-space中随机采样节点并尝试连接它们来构建一个路线图。一旦路线图构建完成，就可以通过图搜索算法（如Dijkstra或A*）在图中查询路径 [4]。
- **快速搜索随机树 (Rapidly-exploring Random Trees, RRT)**：RRT通过增量地生长一棵树来探索C-space。它从起始点开始，随机选择一个点，然后向该点方向扩展树，直到达到目标区域。RRT及其变种（如RRT*）在高维空间和复杂障碍物环境中非常有效 [5]。

### 3.2 基于搜索的方法 (Search-based Methods)

这类方法通常在离散化的空间中进行搜索，能够找到最优路径（如果存在）。

- **Dijkstra算法**：用于在图中寻找最短路径，适用于已知所有边权重的图。
- **A*算法**：一种启发式搜索算法，通过结合Dijkstra算法的优点和启发式信息，提高了搜索效率，常用于网格地图中的路径规划 [6]。

### 3.3 基于优化的方法 (Optimization-based Methods)

这类方法将运动规划问题转化为一个优化问题，通过最小化某个成本函数（如路径长度、平滑度、时间等）来寻找最优轨迹。它们通常需要一个初始路径作为起点，并通过迭代优化来改进路径。

## 4. 代码示例

以下是一个使用Python和`matplotlib`库进行简单2D环境RRT路径规划的示例。此示例仅为概念性演示，不包含完整的机器人运动学和碰撞检测。

```python
import random
import math
import matplotlib.pyplot as plt

class Node:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.parent = None

def dist(node1, node2):
    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)

def steer(from_node, to_node, extend_length):
    new_node = Node(from_node.x, from_node.y)
    theta = math.atan2(to_node.y - from_node.y, to_node.x - from_node.x)
    new_node.x += extend_length * math.cos(theta)
    new_node.y += extend_length * math.sin(theta)
    new_node.parent = from_node
    return new_node

def is_collision_free(node, obstacles):
    # 简化的碰撞检测：检查节点是否在任何圆形障碍物内
    for (ox, oy, r) in obstacles:
        if math.sqrt((node.x - ox)**2 + (node.y - oy)**2) <= r:
            return False
    return True

def rrt_planning(start, goal, obstacles, x_range, y_range, max_iter=500, extend_length=5):
    node_list = [start]

    for _ in range(max_iter):
        # 随机采样一个点
        rnd_node = Node(random.uniform(x_range[0], x_range[1]),
                        random.uniform(y_range[0], y_range[1]))

        # 找到树中最近的节点
        nearest_node = node_list[0]
        for node in node_list:
            if dist(node, rnd_node) < dist(nearest_node, rnd_node):
                nearest_node = node

        # 扩展树
        new_node = steer(nearest_node, rnd_node, extend_length)

        # 检查碰撞并添加到树中
        if is_collision_free(new_node, obstacles):
            node_list.append(new_node)

            # 检查是否到达目标
            if dist(new_node, goal) <= extend_length:
                if is_collision_free(goal, obstacles):
                    goal.parent = new_node
                    node_list.append(goal)
                    return node_list
    return None

def plot_path(node_list, obstacles, start, goal, x_range, y_range):
    plt.figure(figsize=(8, 8))
    for (ox, oy, r) in obstacles:
        circle = plt.Circle((ox, oy), r, color='gray', alpha=0.5)
        plt.gca().add_patch(circle)

    if node_list:
        path = []
        current = node_list[-1]
        while current.parent:
            path.append(current)
            current = current.parent
        path.append(current)
        path.reverse()

        for i in range(len(path) - 1):
            plt.plot([path[i].x, path[i+1].x], [path[i].y, path[i+1].y], '-g')

        for node in node_list:
            if node.parent:
                plt.plot([node.x, node.parent.x], [node.y, node.parent.y], '-b', alpha=0.5)

    plt.plot(start.x, start.y, 'or', markersize=10, label='Start')
    plt.plot(goal.x, goal.y, 'og', markersize=10, label='Goal')
    plt.xlim(x_range)
    plt.ylim(y_range)
    plt.xlabel('X-coordinate')
    plt.ylabel('Y-coordinate')
    plt.title('RRT Motion Planning Example')
    plt.grid(True)
    plt.legend()
    plt.gca().set_aspect('equal', adjustable='box')
    plt.savefig('course/01-robot-grasping-intro/images/rrt_path_planning.png')
    plt.show()

if __name__ == '__main__':
    start_node = Node(10, 10)
    goal_node = Node(90, 90)
    obstacles = [
        (30, 30, 10), (70, 70, 10), (30, 70, 10), (70, 30, 10)
    ]
    x_range = (0, 100)
    y_range = (0, 100)

    path_nodes = rrt_planning(start_node, goal_node, obstacles, x_range, y_range)

    if path_nodes:
        print("Path found!")
        plot_path(path_nodes, obstacles, start_node, goal_node, x_range, y_range)
    else:
        print("No path found.")
```

## 5. 参考资料

- [1] LaValle, S. M. (2006). *Planning Algorithms*. Cambridge University Press.
- [2] Chu, Y., et al. (2025). An Overview and Comparison of Traditional Motion Planning Algorithms for Mobile Robots. *Sensors*, 25(11), 3169. [PMC11991108](https://pmc.ncbi.nlm.nih.gov/articles/PMC11991108/)
- [3] LaValle, S. M. (2011). Motion Planning: The Essentials. *IEEE Robotics & Automation Magazine*, 18(3), 10-22. [PDF](https://lavalle.pl/papers/Lav11b.pdf)
- [4] Kavraki, L. E., Svestka, P., Latombe, J. C., & Overmars, M. H. (1996). Probabilistic roadmaps for path planning in high-dimensional configuration spaces. *IEEE Transactions on Robotics and Automation*, 12(3), 402-413.
- [5] LaValle, S. M. (1998). Rapidly-exploring random trees: A new tool for path planning. *Technical Report, Computer Science Department, Iowa State University*.
- [6] Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. *Numerische Mathematik*, 1(1), 269-271.
