# 2.2 控制算法

- **作者**: Damon Li
- **日期**: 2026年2月4日

## 1. 概述

机器人控制算法是机器人能够精确、稳定地执行任务的基础，它负责根据传感器反馈调整机器人的执行器输出，使其行为符合预期。在机器人抓取与操作中，控制算法确保机器人能够按照规划的路径和轨迹移动，并与环境进行受控的交互，例如施加特定的力或保持柔顺性 [1]。

本节将介绍机器人控制系统的基本概念，并深入探讨几种经典的控制算法，包括比例-积分-微分 (PID) 控制、阻抗控制 (Impedance Control) 和导纳控制 (Admittance Control)。

## 2. 核心原理

机器人控制系统的核心是一个反馈回路，它不断比较机器人的实际状态（通过传感器测量）与期望状态，并计算出必要的控制指令来减小两者之间的误差。这个过程通常涉及以下几个关键概念：

### 2.1 反馈控制系统

反馈控制系统通过测量系统的输出，并将其与期望的输入进行比较，然后利用误差信号来调整系统的行为。这种闭环控制方式能够有效地抑制扰动和不确定性，提高系统的鲁棒性和精度 [2]。

```mermaid
graph TD
    A[期望状态 (Setpoint)] --> B{误差计算}
    B --> C[控制器]
    C --> D[执行器 (机器人)]
    D --> E[实际状态]
    E --> F[传感器]
    F --> B

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#ccf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style D fill:#afa,stroke:#333,stroke-width:2px
    style E fill:#fcf,stroke:#333,stroke-width:2px
    style F fill:#fcf,stroke:#333,stroke-width:2px
```

### 2.2 关节空间控制与操作空间控制

-   **关节空间控制 (Joint Space Control)**：直接控制机器人各个关节的运动（如角度、角速度、力矩）。这种控制方式通常更容易实现，但可能难以直观地控制机器人末端执行器在笛卡尔空间中的运动 [3]。
-   **操作空间控制 (Operational Space Control)**：直接控制机器人末端执行器在笛卡尔空间中的位置、姿态、速度或力。这种控制方式更符合人类直觉，但需要通过逆运动学将操作空间指令转换为关节空间指令 [3]。

## 3. 关键控制方法/算法

### 3.1 比例-积分-微分 (PID) 控制

PID控制器是一种广泛应用于工业和机器人领域的经典反馈控制器，它通过结合比例 (Proportional)、积分 (Integral) 和微分 (Derivative) 三个项来计算控制输出 [4]。

-   **比例项 (P)**：与当前误差成比例，误差越大，控制输出越大，用于快速响应误差。
-   **积分项 (I)**：与误差的累积和成比例，用于消除稳态误差。
-   **微分项 (D)**：与误差的变化率成比例，用于抑制超调和减少振荡，提高系统的稳定性。

PID控制器的输出 $u(t)$ 可以表示为：

$$ u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt} $$

其中，$e(t)$ 是误差信号，$K_p, K_i, K_d$ 分别是比例、积分、微分增益 [5]。

### 3.2 阻抗控制 (Impedance Control)

阻抗控制是一种力-位移控制策略，它不直接控制机器人的位置或力，而是控制机器人末端执行器与环境交互时的动态特性（即机械阻抗）。机器人被控制得像一个具有特定质量、阻尼和刚度的虚拟机械系统 [6]。

其核心思想是建立机器人末端执行器与环境之间期望的力-位移关系，通常表示为一个二阶系统：

$$ M_d \ddot{x} + B_d \dot{x} + K_d x = F_{ext} $$

其中，$M_d, B_d, K_d$ 分别是期望的惯量、阻尼和刚度，$x$ 是末端执行器的位移，$F_{ext}$ 是环境施加的力 [7]。阻抗控制特别适用于需要与环境进行柔顺交互的任务，如装配、抛光、人机协作等。

### 3.3 导纳控制 (Admittance Control)

导纳控制是阻抗控制的对偶形式，它将环境施加的力作为输入，输出机器人的期望运动（位置或速度）。与阻抗控制不同，导纳控制通常在外部力传感器测量到力后，通过一个虚拟导纳模型计算出机器人的响应，然后将这个响应作为位置或速度指令发送给机器人的底层位置或速度控制器 [8]。

导纳控制的优点在于可以利用机器人现有的位置或速度控制器，无需修改底层控制架构。它也适用于需要柔顺交互的任务，但其稳定性分析可能比阻抗控制更复杂。

### 3.4 比较与选择

| 控制方法     | 目标             | 优点                 | 缺点                 | 适用场景                               |
| :----------- | :--------------- | :------------------- | :------------------- | :------------------------------------- |
| **PID控制**  | 减小误差、稳定系统 | 简单、鲁棒、易于实现 | 难以处理复杂非线性、参数调优困难 | 位置/速度控制、简单轨迹跟踪          |
| **阻抗控制** | 控制交互动态特性 | 柔顺性好、适应环境   | 需要力传感器、稳定性分析复杂 | 装配、抛光、人机协作、未知环境交互   |
| **导纳控制** | 响应外部力、生成运动 | 利用现有控制器、柔顺性好 | 稳定性分析复杂、可能引入延迟 | 人机协作、远程操作、力反馈遥操作     |

## 4. 代码示例 (PID 控制器)

以下是一个简单的Python实现的PID控制器示例，用于控制一个模拟的机器人关节位置。

```python
import matplotlib.pyplot as plt

class PIDController:
    def __init__(self, Kp, Ki, Kd, setpoint):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.setpoint = setpoint
        self.prev_error = 0
        self.integral = 0

    def update(self, current_value, dt):
        error = self.setpoint - current_value
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error
        return output

# 模拟机器人关节
class RobotJoint:
    def __init__(self, initial_position=0.0):
        self.position = initial_position
        self.velocity = 0.0
        self.acceleration = 0.0

    def step(self, control_input, dt):
        # 简单的动力学模型：控制输入直接影响加速度
        self.acceleration = control_input * 0.1 # 假设一个简单的比例关系
        self.velocity += self.acceleration * dt
        self.position += self.velocity * dt
        return self.position

if __name__ == "__main__":
    # PID参数
    Kp = 0.5
    Ki = 0.1
    Kd = 0.05
    setpoint = 10.0 # 目标位置

    pid = PIDController(Kp, Ki, Kd, setpoint)
    joint = RobotJoint(initial_position=0.0)

    time_steps = 200
    dt = 0.1 # 时间步长

    positions = []
    times = []

    for i in range(time_steps):
        control_output = pid.update(joint.position, dt)
        current_position = joint.step(control_output, dt)

        positions.append(current_position)
        times.append(i * dt)

    plt.figure(figsize=(10, 6))
    plt.plot(times, positions, label=\'Joint Position\')
    plt.axhline(y=setpoint, color=\'r\', linestyle=\'--\', label=\'Setpoint\')
    plt.xlabel(\'Time (s)\')
    plt.ylabel(\'Position\')
    plt.title(\'PID Control of Robot Joint Position\')
    plt.legend()
    plt.grid(True)
    plt.savefig(\'course/02-classical-control/images/pid_control_example.png\')
    plt.show()
```

## 5. 参考资料

- [1] Technexion. (n.d.). *Control Algorithms in Robotics: From PID to Reinforcement Learning*. Retrieved from [URL](https://www.technexion.com/resources/control-algorithms-in-robotics-from-pid-to-reinforcement-learning/)
- [2] Ogata, K. (2010). *Modern Control Engineering* (5th ed.). Prentice Hall.
- [3] Siciliano, B., & Khatib, O. (Eds.). (2008). *Springer Handbook of Robotics*. Springer.
- [4] Karl Johan Åström, & Richard M. Murray. (2008). *Feedback Systems: An Introduction for Scientists and Engineers*. Princeton University Press.
- [5] Wikipedia. (n.d.). *Proportional–integral–derivative controller*. Retrieved from [URL](https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller)
- [6] Hogan, N. (1985). Impedance Control: An Approach to Manipulation: Part I—Theory. *Journal of Dynamic Systems, Measurement, and Control*, 107(1), 1-7.
- [7] Wang, J. (n.d.). *Impedance Control*. Retrieved from [URL](https://opentextbooks.clemson.edu/wangrobotics/chapter/impedance-control/)
- [8] De Luca, A., & Flacco, F. (2012). Control of robots in contact with the environment: a unified view. *The International Journal of Robotics Research*, 31(10), 1180-1200.
