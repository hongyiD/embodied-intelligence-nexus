# 2.3 机器人抓取和操作方法

- **作者**: Damon Li
- **日期**: 2026年2月4日

## 1. 概述

机器人抓取（Grasping）和操作（Manipulation）是机器人与物理世界交互的两个核心能力。**抓取**是指机器人通过其末端执行器（通常是夹持器或机械手）与物体建立稳定的接触，从而能够提起、保持或移动物体 [1]。**操作**则是在抓取的基础上，通过改变物体的位置、姿态或内部状态来完成特定任务，例如将物体放置到指定位置、拧紧螺丝或组装零件 [2]。

抓取与操作是实现机器人自主完成复杂任务的关键环节，广泛应用于工业生产、物流仓储、医疗服务和家庭辅助等领域。本节将深入探讨抓取与操作的基本概念、面临的挑战、关键问题以及实现稳定抓取的力学条件。

## 2. 核心原理与挑战

### 2.1 抓取与操作的定义

-   **抓取 (Grasping)**：机器人末端执行器与物体之间建立物理接触，以实现对物体的稳定控制。一个成功的抓取需要满足两个基本条件：**力闭合 (Force Closure)** 和 **形闭合 (Form Closure)** [1]。
-   **操作 (Manipulation)**：在抓取或接触的基础上，通过机器人的运动来改变物体的状态（位置、姿态、形状等）或执行特定任务。操作通常涉及更复杂的运动规划和力控制 [2]。

### 2.2 抓取面临的挑战

机器人抓取是一个极具挑战性的问题，主要原因包括 [3]：

-   **物体多样性**：现实世界中的物体形状、尺寸、材质、重量、表面摩擦力各异，这使得设计通用的抓取策略非常困难。
-   **环境不确定性**：物体可能处于杂乱堆叠的环境中，或者被遮挡，导致感知困难。
-   **感知误差**：传感器数据可能存在噪声或不准确，影响对物体位姿和几何形状的估计。
-   **动力学与接触建模**：抓取过程中机器人与物体之间的接触是非线性的、不确定的，精确建模非常复杂。
-   **实时性要求**：许多应用场景要求机器人能够快速响应，在短时间内完成抓取决策和执行。

### 2.3 抓取问题 (Grasping Problem)

抓取问题可以形式化为：给定一个机器人末端执行器和一个待抓取物体，找到一组接触点和相应的接触力，使得物体在抓取后能够稳定地被机器人控制，并且能够抵抗外部扰动 [1]。这通常涉及以下几个子问题：

-   **抓取点/姿态生成 (Grasp Pose Generation)**：确定机器人夹持器相对于物体的最佳位置和方向。
-   **抓取力规划 (Grasp Force Planning)**：确定在每个接触点上施加的力，以确保抓取稳定性。
-   **碰撞检测 (Collision Detection)**：确保抓取动作不会导致机器人自身或与环境发生碰撞。

## 3. 抓取稳定性条件

为了确保抓取的稳定性，通常需要满足力闭合或形闭合条件。

### 3.1 力闭合 (Force Closure)

**力闭合**是指在抓取物体时，通过在接触点施加适当的力，能够抵抗来自任何方向的外部扰动力和力矩，从而使物体保持稳定 [1] [4]。如果一个抓取是力闭合的，那么即使物体受到外部推拉或扭转，机器人也能通过调整接触力来维持对物体的控制，防止物体从手中滑落或旋转。

数学上，力闭合通常通过分析抓取接触点产生的力锥（friction cones）来判断。如果所有可能的外部扰动都能够被这些力锥的线性组合所抵消，则抓取是力闭合的。

### 3.2 形闭合 (Form Closure)

**形闭合**是指在抓取物体时，仅通过接触点的几何约束，就能完全限制物体的所有自由度，使其无法在不穿透夹持器或物体的情况下移动 [1] [4]。形闭合的抓取不需要施加任何力就能保持物体稳定，但通常需要更多的接触点或更复杂的夹持器形状。

形闭合是一种更强的抓取稳定性条件，它意味着物体被完全“锁住”在夹持器中。在实际应用中，由于夹持器形状和接触点数量的限制，纯粹的形闭合抓取较难实现，通常会追求力闭合。

### 3.3 简单抓取计算流程

一个简化的抓取计算流程通常包括以下步骤：

1.  **物体感知**：利用视觉传感器（如RGB-D相机）获取物体的3D点云或图像信息，进行物体识别和位姿估计。
2.  **抓取候选生成**：根据物体的几何形状和夹持器的类型，生成一系列可能的抓取姿态（例如，通过几何启发式方法或数据驱动方法）。
3.  **抓取评估**：对每个抓取候选进行稳定性评估，例如计算力闭合度、碰撞检测、可达性分析等。选择得分最高的抓取姿态。
4.  **抓取执行**：机器人移动到选定的抓取姿态，闭合夹持器，施加抓取力。
5.  **抓取验证**：通过传感器反馈（如力传感器、视觉）验证抓取是否成功。如果失败，可能需要重新规划或调整抓取策略。

## 4. 代码示例 (力闭合可视化概念)

以下是一个概念性的Python代码片段，用于说明力闭合的几何原理。它模拟了两个接触点对一个2D物体施加力，并可视化摩擦锥。这并非一个完整的抓取规划算法，而是用于理解力闭合概念。

```python
import matplotlib.pyplot as plt
import numpy as np

def plot_friction_cone(ax, contact_point, normal_vector, friction_coeff, scale=1.0):
    # 摩擦锥的半角
    friction_angle = np.arctan(friction_coeff)

    # 法线方向
    nx, ny = normal_vector / np.linalg.norm(normal_vector)

    # 摩擦锥的两个边界向量
    # 旋转法线向量 +/- 摩擦角
    R1 = np.array([[np.cos(friction_angle), -np.sin(friction_angle)],
                   [np.sin(friction_angle), np.cos(friction_angle)]])
    R2 = np.array([[np.cos(-friction_angle), -np.sin(-friction_angle)],
                   [np.sin(-friction_angle), np.cos(-friction_angle)]])

    v1 = R1 @ np.array([nx, ny])
    v2 = R2 @ np.array([nx, ny])

    # 绘制摩擦锥
    ax.plot([contact_point[0], contact_point[0] + v1[0] * scale],
            [contact_point[1], contact_point[1] + v1[1] * scale], 
            color=\'blue’, linestyle=\'--\', alpha=0.7)
    ax.plot([contact_point[0], contact_point[0] + v2[0] * scale],
            [contact_point[1], contact_point[1] + v2[1] * scale], 
            color=\'blue’, linestyle=\'--\', alpha=0.7)
    ax.plot([contact_point[0], contact_point[0] + nx * scale],
            [contact_point[1], contact_point[1] + ny * scale], 
            color=\'red’, linewidth=2, alpha=0.8, label=\'Normal Force\')

    # 绘制接触点
    ax.plot(contact_point[0], contact_point[1], ‘ko’, markersize=5)


if __name__ == ‘__main__’:
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_xlim(0, 10)
    ax.set_ylim(0, 10)
    ax.set_aspect(‘equal’, adjustable=‘box’)
    ax.set_title(‘Force Closure Concept: Friction Cones’)
    ax.set_xlabel(‘X’)
    ax.set_ylabel(‘Y’)
    ax.grid(True)

    # 模拟物体中心
    object_center = np.array([5, 5])
    ax.plot(object_center[0], object_center[1], ‘x’, color=‘purple’, markersize=10, label=‘Object Center’)

    # 接触点1
    contact1 = np.array([4, 5])
    normal1 = np.array([1, 0]) # 法线向右
    plot_friction_cone(ax, contact1, normal1, friction_coeff=0.5, scale=1.5)

    # 接触点2
    contact2 = np.array([6, 5])
    normal2 = np.array([-1, 0]) # 法线向左
    plot_friction_cone(ax, contact2, normal2, friction_coeff=0.5, scale=1.5)

    ax.legend()
    plt.savefig(‘course/02-classical-control/images/force_closure_concept.png’)
    plt.show()
```

## 5. 参考资料

- [1] Murray, R. M., Li, Z., & Sastry, S. S. (1994). *A Mathematical Introduction to Robotic Manipulation*. CRC Press.
- [2] Bai, S., et al. (2025). Towards a Unified Understanding of Robot Manipulation. *arXiv preprint arXiv:2510.10903*.
- [3] Morales, A., et al. (2022). Editorial: Current Challenges and Future Developments in Robot Grasping. *Frontiers in Robotics and AI*, 9, 9310340. [PMC9310340](https://pmc.ncbi.nlm.nih.gov/articles/PMC9310340/)
- [4] Mason, M. T., & Salisbury, J. K. (1985). *Robot Hands and the Mechanics of Manipulation*. MIT Press.
